# 命令式与声明式

## 命令式框架
命令式框架的特点就是`关注过程`。例如, 将下面这段话翻译成对应的代码：
- 获取 id 为 app的 div标签
- 它的文本内容为hello world
- 为其绑定点击事件
- 当点击时弹出提示： ok

对应的代码为：
```js
  const div = document.querySelector('#app') // 获取div
  div.innerText = 'Hello World' // 设置文本内容
  div.addEventListener('click', () => { alert('ok')})
```

自然语言描述能够与代码产生一一对应的关系，代码本身描述的是"做事的过程"，这就是命令式。

## 声明式框架
声明式框架与命令式框架不同，它则是`关注结果`。如下：
```vue
<div @click="() => alert('ok')">Hello World</div>
```
可以看到，我们提供的是一个`结果`, 至于如何实现这个`结果`, 我们并不关心。可以理解为，Vuejs帮我们封装了`过程`，所以它的内部实现一定是`命令式`的，而暴露给用户的却更加`声明式`。

# 性能与可维护性

## 性能的优劣
命令式和声明式各有优缺点，在框架设计方面，则体现在性能与可维护之间的权衡。这里我们先抛出一个结论：`声明式代码的性能不优于命令式代码的性能`。

拿上面的例子来说，假设我们要将div标签的文本内容修改为 hello vue3，那么如何用命令式代码实现呢？很简单，因为我们知道要修改的是什么，所以直接调用相关属性方法即可：
```js
div.textContent = 'hello vue3' // 直接修改
```
可以看到，理论上命令式代码可以做到极致的性能优化，因为我们明确知道哪些发生了变更，只做必要的修改就行了。但是声明式代码不一定能做到这一点，因为它描述的是结果：
```vue
01 <!-- 之前： -->
02 <div @click="() => alert('ok')">hello world</div>
03 <!-- 之后： -->
04 <div @click="() => alert('ok')">hello vue3</div>
```
对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是：
```js
div.textContent = 'hello vue3' // 直接修改
```
如果我们把修改的性能消耗定义为A，把找出差异的性能消耗定义为B，那么有：
- 命令式代码的更新性能消耗 = A
- 声明式代码的更新性能消耗 = B + A

可以看到，声明式代码会命令式代码多出找出差异的性能消耗，因此最理想的情况是，当找出差异的性能消耗为0时，声明式代码与命令式代码的性能相同，但是无法做到超越，
`毕竟框架本身就是封装了命令式代码才实现了面向用户的声明式。`这符合前文给出的性能结论：`声明式代码的性能不优于命令式代码的性能`。

## 可维护性

既然在性能层面命令式代码更好的选择，那么为什么vue.js要选择声明式的设计方案呢？原因就在于`声明式代码的可维护性更强`。从上面的例子代码我们也可以感受到，在采用命令式代码开发的时候，我们需要维护实现目标的整个`过程`，包括要手动完成DOM元素的创建、更新、删除等工作。而声明式代码展示的就是我们要的`结果`,看上去更加直观，至于完成的过程，则并不需要我们关心。


这就体现了我们在框架设计上要做出的关于可维护性与性能之间的权衡。在采用声明式提升可维护性的同时，性能就会有一定的损失，而框架设计者要做的就是：`在保持可维护性的同时让性能损失最小化。`

# 虚拟DOM的性能到底如何

## 为什么会有虚拟DOM
`声明式的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗`，因此，如果我们能够最小化`找出差异的性能消耗`, 就可以让声明式代码的性能无限接近命令式代码的性能。而所谓的虚拟DOM，就是为了`最小化`找出差异这一步的性能消耗而出现的。

理论上来说，采用虚拟DOM的更新技术的性能不可能比原生Javascript操作DOM更高。因为在大部分情况下，`我们很难写出绝对优化的命令式代码`，尤其是当应用程序的规模很大的时候，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。

那么，有没有什么办法能够让我们不用付出太多的努力(写声明式代码)，还能够保证应用程序的性能下限，让应用程序的性能不至于太差，甚至想办法逼近命令式代码的性能呢？这其实就是虚拟DOM要解决的问题。

## innerHTML和虚拟DOM的创建页面过程

首先我们来讨论innerHTML在创建页面时的性能。对于innerHTML来说，为了创建页面，我们需要构造一段HTML代码：
```js
01 const html = `<div><span>...</span></div>`
```
接着将该字符串赋值给DOM元素的innerHTML属性：
```js
div.innerHTML= html
```

innerHTML创建页面的性能为： `HTML字符串拼接的计算量 + innerHTML的DOM计算量`

接下来，我们讨论虚拟DOM在创建页面时的性能。虚拟DOM创建页面的过程分为两步：第一步是创建Javascript对象，这个对象可以理解为真实DOM的描述；第二步是递归地遍历虚拟DOM树并创建真实DOM。

虚拟DOM创建页面的性能为：`创建Javascript对象的计算量 + 创建真实DOM的计算量`

此时两者在js运算与DOM运算时的表现为：
- js运算：innerHTML渲染HTML字符串，虚拟DOM则是创建Js对象(VNode)
- DOM运算：二者都会新建所有DOM元素

可以看到，无论是纯js层面的运算，还是DOM层面的计算，其实两者差距不大。这里我们从宏观的角度只看数量级上的差异。如果在同一个数量级，则认为没有差异。在创建页面的时候，都需要新建所有DOM元素。

## 更新过程
从以上的对比来看，虚拟DOM较之innerHTML基本没有优势可言，甚至细究的话性能可能更差。那为什么还要用虚拟DOM呢，我们接下来看看它们在更新页面时的性能。

使用innerHTML更新页面的过程是`重新构建HTML字符串，再重新设置DOM的innerHTML`属性，这其实是再说，哪怕我们只更改一个文字，也要重新设置innerHTML属性。而重新设置innerHTML属性就等价于`销毁所有旧的DOM元素，再全量创建新的DOM元素。`而虚拟DOM则是`重新创建Javascript对象(虚拟DOM树)，然后比较新旧虚拟DOM，找到变化的元素并更新它。`

此时两者在js运算与DOM运算时的表现为：
- js运算：innerHTML渲染HTML字符串，虚拟DOM则是创建新的Js对象 + Diff
- DOM运算：innerHTML会销毁所有旧DOM，新建所有新DOM。虚拟DOM则只会进行必要的DOM更新

可以发现，在更新页面时，虚拟DOM在Javascript层面的运算要比创建页面时多出一个Diff的性能消耗，然而它毕竟也是js层面的运算，所以不会产生数量级的差异。再观察DOM层面的运算，可以发现虚拟DOM在更新页面时只会更新必要的元素，但innerHTML需要全量更新。这时虚拟DOM的优势就体现出来了。

另外，当更新页面时，影响虚拟DOM的性能因素与影响innerHTML的性能因素不同。对于虚拟DOM来说，无论页面多大，都只会更新变化的内容，而对于innerHTML来说，页面越大，就意味着更新时的性能消耗越大。

两者在更新时的性能因素：
- innerHTML：与模板大小相关
- 虚拟DOM：与数据变化量相关

